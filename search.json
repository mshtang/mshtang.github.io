[{"title":"An Overall View of Concurrency in C#","url":"/2021/03/28/An-Overall-View-of-Concurrency-in-Csharp/","content":"This article is largely excerpted from the “Concurrency in C# Cookbook” by Stephen Cleary.\nIntroduction to ConcurrencyConcurrency: Doing more than one thing at a timeMultithreading: A form of concurrency that uses multiple threads of execution\nParallel processing: Doing lots of work by dividing it up among multiple threads that run concurrently\n\nParallel processing is one type of multithreading, and multithreading is one type of concurrency.\n\nAsynchronous programming: A form of concurrency that uses futures or callbacks to avoid unnecessary threads\nReactive programming: A declarative style of programming where the application reacts to events\nIntroduction to Asynchronous ProgrammingThe core of async programming is the Task and Task&lt;T&gt; objects, which model asynchronous operations. They are supported by the async and await keywords. The model is fairly simple in most cases:\n\nFor I&#x2F;O-bound code, you await an operation that returns a Task or Task&lt;T&gt; inside of an async method.\n\nFor CPU-bound code, you await an operation that is started on a background thread with the Task.Run method.\n\n\nRecognize CPU-bound and I&#x2F;O-bound workHere are two questions you should ask before you write any code:\n\nWill your code be “waiting” for something, such as data from a database? If your answer is “yes”, then your work is I&#x2F;O-bound.\n\nWill your code be performing an expensive computation? If you answered “yes”, then your work is CPU-bound.\n\n\nIf the work you have is I&#x2F;O-bound, use async and await without Task.Run. You should not use the Task Parallel Library. \nIf the work you have is CPU-bound and you care about responsiveness, use async and await, but spawn off the work on another thread with Task.Run. If the work is appropriate for concurrency and parallelism, also consider using the Task Parallel Library.\nasync Task DoSomethingAsync()&#123;  int value = 13;  // Asynchronously wait 1 second.  await Task.Delay(TimeSpan.FromSeconds(1));  value *= 2;  // Asynchronously wait 1 second.  await Task.Delay(TimeSpan.FromSeconds(1));  Trace.WriteLine(value);&#125;\n\nYou can think of an async method as having several synchronous portions, broken up by await statements. The first synchronous portion executes on whatever thread calls the method, but where do the other synchronous portions execute? The answer is a bit complicated. \nWhen you await a task (the most common scenario), a context is captured when the await decides to pause the method. This is the current SynchronizationContext unless it’s null, in which case the context is the current TaskScheduler. The method resumes executing within that captured context. Usually, this context is the UI context (if you’re on the UI thread) or the threadpool context (most other situations).\nSo, in the preceding code, all the synchronous portions will attempt to resume on the original context. If you call DoSomethingAsync from a UI thread, each of its synchronous portions will run on that UI thread; but if you call it from a threadpool thread, each of its synchronous portions will run on any threadpool thread.\nYou can avoid this default behavior by awaiting the result of the ConfigureAwait extension method and passing false for the continueOnCapturedContext parameter. The following code will start on the calling thread, and after it is paused by an await, it’ll resume on a threadpool thread:\nasync Task DoSomethingAsync()&#123;  int value = 13;  // Asynchronously wait 1 second.  await Task.Delay(TimeSpan.FromSeconds(1)).ConfigureAwait(false);  value *= 2;  // Asynchronously wait 1 second.  await Task.Delay(TimeSpan.FromSeconds(1)).ConfigureAwait(false);  Trace.WriteLine(value);&#125;\n\n\nIt’s good practice to always call ConfigureAwait(false) in your core “library” methods, and only resume the context when you need it—in your outer “user interface” methods.\n\n\nit’s also a good idea to be aware of context when writing async code. Normally, an async method should either require context (dealing with UI elements or ASP.NET requests&#x2F;response) or be free from context (doing background operations). If you have an async method that has parts requiring context and parts free from context, consider splitting up into two (or more) async methods.\n\n\nOnce you start using async, it’s best to allow it to grow through your code.  If you call an async method, you should (eventually) await the task it returns. Resist the temptation to call Task.Wait, Task&lt;TResult&gt;.Result, or GetAwaiter().GetResult(); doing so could cause a deadlock.\n\nIntroduction to Parallel ProgrammingParallel programming should be used any time you have a fair amount of computation work that can be split up into independent chunks. Parallel programming increases the CPU usage temporarily to improve throughput; this is desirable on client systems where CPUs are often idle, but it’s usually not appropriate for server systems. Parallel programming on the server would work against its built-in parallelism and therefore wouldn’t provide any real benefit.\nThere are two forms of parallelism: data parallelism and task parallelism. Data parallelism is when you have a bunch of data items to process, and the processing of each piece of data is mostly independent from the other pieces. Task parallelism is when you have a pool of work to do, and each piece of work is mostly independent from the other pieces. Task parallelism may be dynamic; if one piece of work results in several additional pieces of work, they can be added to the pool of work.\nTo do data parallelism, use Parallel.ForEach (Parallel.For) or PLINQ, which provides an AsParallel extension method for LINQ queries.To do task parallelism, use Parallel.Invoke, which is one type of Parallel method that does a kind of fork&#x2F;join task parallelism.\n\nOne difference between Parallel and PLINQ is that PLINQ assumes it can use all the cores on the computer, while Parallel will dynamically react to changing CPU conditions.\n\nData parallelism is focused on processing data; task parallelism is just about doing work. At a high level, data parallelism and task parallelism are similar; “processing data” is a kind of “work.” Many parallelism problems can be solved either way; it’s convenient to use whichever API is more natural for the problem at hand.\n\nThe chunks of work should be as independent from one another as possible when using parallel programming.\n\n\nTasks should neither be extremely short nor extremely long.\n\nModern DesignMost concurrent technologies have one similar aspect: they are functional in nature. \nOne principle of functional programming is purity (that is, avoiding side effects). Each piece of the solution takes some value(s) as input and produces some value(s) as output. As much as possible, you should avoid having these pieces depend on global (or shared) variables or update global (or shared) data structures. This is true whether the piece is an async method, a parallel task, a System.Reactive operation, or a dataflow block.\n","categories":["Programming","Books","Concurrency in C# Cookbook"],"tags":["C#"]},{"title":"Express Timeout with Cancellation","url":"/2021/04/04/Express-Timeout-with-Cancellation/","content":"It’s possible to use Task.WhenAny to implement timeouts (e.g. using Task.Delay as one of the tasks), but it’s not recommended. Cancellation is a natural solution for timeout situations, because a timeout is just one type of cancellation request. The code that needs to be canceled merely observe the cancellation token, it should neither know nor care that the cancellation source is a timer.\nasync Task IssueTimeoutAsync()&#123;    using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));    CancellationToken token = cts.Token;    await Task.Delay(TimeSpan.FromSeconds(10), token);&#125;\n\nIf you already have a CancellationTokenSource instance, you can start a timeout for that instance:\nasync Task IssueTimeoutAsync()&#123;    using var cts = new CancellationTokenSource();    CancellationToken token = cts.Token;    cts.CancelAfter(TimeSpan.FromSeconds(5));    await Task.Delay(TimeSpan.FromSeconds(10), token);&#125;","categories":["Programming","Books","Concurrency in C# Cookbook"],"tags":["C#"]},{"title":"Kernel Thread States","url":"/2022/04/27/Kernel-Thread-States/","content":"This is a simple introduction of the kernel thread state.\n\n\nWhen kernel bootstraps, it will create a kernel thread, some kernel services will be started up in the kernel thread. And these same services will create new threads.\nAfter a thread is created, it is ready for executing. After CPU schedules it, it changes to running state.\nA thread will change to waiting state when receiving events, and switch to ready state when it is woken up.\nIf a thread is forced to terminate, the state will change to stopped.\nA user thread state is similar to a kernel thread.\n","categories":["Programming"],"tags":["OS"]},{"title":"Naming Conventions for LINQ Operators for Asynchronous Streams","url":"/2021/04/04/Naming-Conventions-for-LINQ-Operators-for-Asynchronous-Streams/","content":"Some of the LINQ operators for asynchronous streams end in Async while others end in Await, e.g. WhereAwait and CountAsync etc.\nThe operators that end in Await take an asynchronous delegate; the Await in their name implies that they actually perform an await on the delegate you pass to them.\nIAsyncEnumerable&lt;int&gt; values = SlowRange().WhereAwait(     async value =&gt;     &#123;         // Do something asynchronous to determine if          // this element should be included         await Task.Delay(10);         return value % 2 == 0;     &#125;);await foreach (var result in values)&#123;    Console.WriteLine(result);&#125;// Produce sequence that slows down as it progressesasync IAsyncEnumerable&lt;int&gt; SlowRange()&#123;    for(int i = 0; i != 10; i++)    &#123;        await Task.Delay(i * 100);        yield return i;    &#125;&#125;\nIt also makes sense to apply a synchronous Where to the asynchronous stream in the above example. The result is still an asynchronous stream:\nIAsyncEnumerable&lt;int&gt; values = SlowRange().Where(     value =&gt; value % 2 == 0);await foreach (var result in values)&#123;    Console.WriteLine(result);&#125;\n\nThe operators that end in Async return an awaitable; they represent a regular value, not an asynchronous sequence. The Async suffix only applies to termination operators, i.e., operators that extract some value or return an asynchronous scalar value after performing some calculation, such as CountAsync.\nint count = await SlowRange().CountAsync(value =&gt; value % 2 == 0);\n\nIf the predicate happens to be also asynchronous, in which case you would then use the CountAwaitAsync operator:\nint count = await SlowRange().CountAwaitAsync(    async value =&gt;     &#123;        await Task.Delay(10);        return value % 2 == 0;        &#125;);\n","categories":["Programming","Books","Concurrency in C# Cookbook"],"tags":["C#"]},{"title":"XAML Style and Resource Dictionary","url":"/2022/05/10/XAML-styles/","content":"ResourceDictionary and XAML resource references&lt;Page    x:Class=&quot;MSDNSample.MainPage&quot;    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;    &lt;Page.Resources&gt;        &lt;x:String x:Key=&quot;greeting&quot;&gt;Hello world&lt;/x:String&gt;        &lt;x:String x:Key=&quot;goodbye&quot;&gt;Goodbye world&lt;/x:String&gt;    &lt;/Page.Resources&gt;    &lt;TextBlock Text=&quot;&#123;StaticResource greeting&#125;&quot; Foreground=&quot;Gray&quot; VerticalAlignment=&quot;Center&quot;/&gt;&lt;/Page&gt;\n\nIn this example:\n\n&lt;Page.Resources&gt;…&lt;/Page.Resources&gt; - Defines the resource dictionary.\n&lt;x:String&gt; - Defines the resource with the key “greeting”.\n&#123;StaticResource greeting&#125; - Looks up the resource with the key “greeting”, which is assigned to the Text property of the TextBlock.\n\nResources don’t have to be strings; they can be any shareable object, such as styles, templates, brushes, and colors. However, controls, shapes, and other FrameworkElements are not shareable, so they can’t be declared as reusable resources.\nAll resources need to have a key. Usually that key is a string defined with x:Key=&quot;myString&quot;. However, there are a few other ways to specify a key:\n\nStyle and ControlTemplate require a TargetType, and will use the TargetType as the key if x:Key is not specified. In this case, the key is the actual Type object, not a string. (See examples below)\nDataTemplate resources that have a TargetType will use the TargetType as the key if x:Key is not specified. In this case, the key is the actual Type object, not a string.\nx:Name can be used instead of x:Key. However, x:Name also generates a code behind field for the resource. As a result, x:Name is less efficient than x:Key because that field needs to be initialized when the page is loaded.\n\nHere, the Style has an implicit key of typeof(Button), and since the Button at the bottom of the page doesn’t specify a Style property, it looks for a style with key of typeof(Button):\n&lt;Page    x:Class=&quot;MSDNSample.MainPage&quot;    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;    &lt;Page.Resources&gt;        &lt;Style TargetType=&quot;Button&quot;&gt;            &lt;Setter Property=&quot;Background&quot; Value=&quot;Red&quot;/&gt;        &lt;/Style&gt;    &lt;/Page.Resources&gt;    &lt;Grid&gt;       &lt;!-- This button will have a red background. --&gt;       &lt;Button Content=&quot;Button&quot; Height=&quot;100&quot; VerticalAlignment=&quot;Center&quot; Width=&quot;100&quot;/&gt;    &lt;/Grid&gt;&lt;/Page&gt;\nEvery FrameworkElement can have a ResourceDictionaryFrameworkElement is a base class that controls inherit from, and it has a Resources property. So, you can add a local resource dictionary to any FrameworkElement.\nHere, both the Page and the Border have resource dictionaries, and they both have a resource called “greeting”. The TextBlock named ‘textBlock2’ is inside the Border, so its resource lookup looks first to the Border’s resources, then the Page’s resources, and then the Application resources. The TextBlock will read “Hola mundo”.\n&lt;Page    x:Class=&quot;MSDNSample.MainPage&quot;    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;    &lt;Page.Resources&gt;        &lt;x:String x:Key=&quot;greeting&quot;&gt;Hello world&lt;/x:String&gt;    &lt;/Page.Resources&gt;        &lt;StackPanel&gt;        &lt;!-- Displays &quot;Hello world&quot; --&gt;        &lt;TextBlock x:Name=&quot;textBlock1&quot; Text=&quot;&#123;StaticResource greeting&#125;&quot;/&gt;        &lt;Border x:Name=&quot;border&quot;&gt;            &lt;Border.Resources&gt;                &lt;x:String x:Key=&quot;greeting&quot;&gt;Hola mundo&lt;/x:String&gt;            &lt;/Border.Resources&gt;            &lt;!-- Displays &quot;Hola mundo&quot; --&gt;            &lt;TextBlock x:Name=&quot;textBlock2&quot; Text=&quot;&#123;StaticResource greeting&#125;&quot;/&gt;        &lt;/Border&gt;        &lt;!-- Displays &quot;Hola mundo&quot;, set in code. --&gt;        &lt;TextBlock x:Name=&quot;textBlock3&quot;/&gt;    &lt;/StackPanel&gt;&lt;/Page&gt;\n\nMerged resource dictionariesA merged resource dictionary combines one resource dictionary into another, usually in another file.\nHere, you define a resource dictionary in a separate XAML file called Dictionary1.xaml.\n&lt;!-- Dictionary1.xaml --&gt;&lt;ResourceDictionary    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;     xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;    xmlns:local=&quot;using:MSDNSample&quot;&gt;    &lt;SolidColorBrush x:Key=&quot;brush&quot; Color=&quot;Red&quot;/&gt;&lt;/ResourceDictionary&gt;\n\nTo use that dictionary, you merge it with your page’s dictionary:\n&lt;Page    x:Class=&quot;MSDNSample.MainPage&quot;    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;    &lt;Page.Resources&gt;        &lt;ResourceDictionary&gt;            &lt;ResourceDictionary.MergedDictionaries&gt;                &lt;ResourceDictionary Source=&quot;Dictionary1.xaml&quot;/&gt;            &lt;/ResourceDictionary.MergedDictionaries&gt;            &lt;x:String x:Key=&quot;greeting&quot;&gt;Hello world&lt;/x:String&gt;        &lt;/ResourceDictionary&gt;    &lt;/Page.Resources&gt;    &lt;TextBlock Foreground=&quot;&#123;StaticResource brush&#125;&quot; Text=&quot;&#123;StaticResource greeting&#125;&quot; VerticalAlignment=&quot;Center&quot;/&gt;&lt;/Page&gt;\nHere’s what happens in this example. In &lt;Page.Resources&gt;, you declare &lt;ResourceDictionary&gt;. The XAML framework implicitly creates a resource dictionary for you when you add resources to &lt;Page.Resources&gt;; however, in this case, you don’t want just any resource dictionary, you want one that contains merged dictionaries.\nSo you declare &lt;ResourceDictionary&gt;, then add things to its &lt;ResourceDictionary.MergedDictionaries&gt; collection. Each of those entries takes the form &lt;ResourceDictionary Source=&quot;Dictionary1.xaml&quot;/&gt;. To add more than one dictionary, just add a &lt;ResourceDictionary Source=&quot;Dictionary2.xaml&quot;/&gt; entry after the first entry.\nAfter &lt;ResourceDictionary.MergedDictionaries&gt;…&lt;/ResourceDictionary.MergedDictionaries&gt;, you can optionally put additional resources in your main dictionary. You use resources from a merged to dictionary just like a regular dictionary. In the example above, &#123;StaticResource brush&#125; finds the resource in the child&#x2F;merged dictionary (Dictionary1.xaml), while &#123;StaticResource greeting&#125; finds its resource in the main page dictionary.\nIn the resource-lookup sequence, a MergedDictionaries dictionary is checked only after a check of all the other keyed resources of that ResourceDictionary. After searching that level, the lookup reaches the merged dictionaries, and each item in MergedDictionaries is checked. If multiple merged dictionaries exist, these dictionaries are checked in the inverse of the order in which they are declared in the MergedDictionaries property. In the following example, if both Dictionary2.xaml and Dictionary1.xaml declared the same key, the key from Dictionary2.xaml is used first because it’s last in the MergedDictionaries set.\n&lt;Page    x:Class=&quot;MSDNSample.MainPage&quot;    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;    &lt;Page.Resources&gt;        &lt;ResourceDictionary&gt;            &lt;ResourceDictionary.MergedDictionaries&gt;                &lt;ResourceDictionary Source=&quot;Dictionary1.xaml&quot;/&gt;                &lt;ResourceDictionary Source=&quot;Dictionary2.xaml&quot;/&gt;            &lt;/ResourceDictionary.MergedDictionaries&gt;        &lt;/ResourceDictionary&gt;    &lt;/Page.Resources&gt;    &lt;TextBlock Foreground=&quot;&#123;StaticResource brush&#125;&quot; Text=&quot;greetings!&quot; VerticalAlignment=&quot;Center&quot;/&gt;&lt;/Page&gt;\n\n\nRemember that any value you provide in a primary resource dictionary is always checked before the merged dictionaries are checked.\n\nSee also: XAML resource dictionary on Microsoft Docs\n","categories":["Programming"],"tags":["XMAL","WPF"]},{"title":"XML Schema nillable=\"true\" vs. minOccurs=\"0\"","url":"/2022/03/23/XML-Schema-nillable-true-vs-minOccurs-0/","content":"Assume the following xsd:\n&lt;xs:element name=&quot;myelements&quot;&gt;  &lt;xs:complexType&gt;    &lt;xs:sequence&gt;      &lt;xs:element name=&quot;nonBoth&quot; type=&quot;xs:string&quot; minOccurs=&quot;1&quot; nillable=&quot;false&quot;/&gt;      &lt;xs:element name=&quot;minZero&quot; type=&quot;xs:int&quot; minOccurs=&quot;0&quot; nillable=&quot;false&quot;/&gt;      &lt;xs:element name=&quot;nilInt&quot; type=&quot;xs:int&quot; minOccurs=&quot;1&quot; nillable=&quot;true&quot; /&gt;      &lt;xs:element name=&quot;nilString&quot; type=&quot;xs:string&quot; minOccurs=&quot;1&quot; nillable=&quot;true&quot;/&gt;      &lt;xs:element name=&quot;minZeroNil&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot; nillable=&quot;true&quot;/&gt;    &lt;/xs:sequence&gt;  &lt;/xs:complexType&gt;&lt;/xs:element&gt;\nA valid xml for this xsd can be:\n&lt;myelements&gt;  &lt;nonBoth&gt;i can&#x27;t neither be nil nor be skipped&lt;nonBoth&gt;  &lt;minZero&gt;3&lt;minZero&gt;  &lt;nilInt&gt;0&lt;/nilInt&gt;  &lt;nilString&gt;i can be null, but i cannot be skiped&lt;/nilString&gt;  &lt;minZeroNil&gt;i can be skipped and have the nil value&lt;/minZeroNil&gt; &lt;!-- if null, won&#x27;t appear--&gt;&lt;/myelements&gt;\nAnother valid xml can be:\n&lt;myelements&gt;  &lt;nonBoth&gt;i can&#x27;t neither be nil nor be skipped&lt;nonBoth&gt;  &lt;!--No show of &lt;minZero/&gt; in xml as element is ignored--&gt;  &lt;nilInt xsi:nil=&quot;true&quot;/&gt; &lt;!--element is null but still exists in xml--&gt;  &lt;nilString xsi:nil=&quot;true&quot;/&gt; &lt;!--element is null but still exists in xml--&gt;  &lt;!-- No show of &lt;minZeroNil&gt; if it&#x27;s value is null, alternatively, this element can be--&gt;  &lt;minZeroNil xsi:nil=&quot;true&quot;/&gt;&lt;/myelements&gt;\n\nThen what’s the differeces between the attribute nillable=&quot;true&quot; and minOccurs=&quot;0&quot;?\nnillable by default is set to false and minOccurs to 1.\n\n\n\nminOccurs=0\nminOccurs=1\n\n\n\nnillable=true\nif the element doesn’t have a value,  the element can either be omitted in xml   or its value can be set to ‘nil’  (as element 5)\nelement can be nill but cannot be omitted  in other words, &lt;nilInt xsi:nil=&quot;true&quot;/&gt;  is presented in xml in case element is nill (^)  (as element 3 or 4)\n\n\nnillable=false\nelement can be ignored and  then is omitted in xml (as element 2)\n(default) element must have value (not nill)   and can’t be omitted (as element 1)\n\n\n\n(^): The correct way to declare an element is nil is: &lt;nilint xsi:nil=&quot;true&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;/&gt; The xmlns:xsi attribute can be put in the root element as:\n\n&lt;myelements xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;/&gt;  &lt;nonBoth&gt;&lt;nonBoth&gt;  &lt;nilInt xsi:nil=&quot;true&quot;/&gt;  &lt;nilstring xsi:nil=&quot;true&quot;&gt;&lt;/myelements&gt;\n\nWhich is the minimal xml that conforms to the xsd.\n\n"},{"title":"Hexo Quick Start Reference","url":"/2020/04/07/hello-world/","content":"This blog is built on Hexo with the theme keep. Useful links include the official Hexo documentation and the official keep documentation. Answers to any problems can be found in troubleshooting.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nCreate a draft$ hexo new draft &quot;My New Draft&quot;\n\nPublish a draftPosts initialized with draft layout are saved to the source/_drafts folder. Use the publish command to move drafts to the source/_posts folder.\n$ hexo publish [layout] &lt;title&gt;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nClean static files$ hexo clean\n\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Hexo"],"tags":["Hexo"]}]